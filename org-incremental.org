#+TITLE: org-incremental
#+BRAIN_FRIENDS: 1917a9f7-ee66-4023-a0ff-f9e52a0970c1 incremental_reading
#+BRAIN_PARENTS: system literate-projects
#+PROPERTY: header-args :noweb yes
#+FILETAGS: incremental
#+org_incremental: t
# #+LATEX_HEADER: \usepackage{minted}
#+LATEX_HEADER: \usepackage{tikz}
#+LATEX_HEADER: \usepackage{svg}
#+OPTIONS: tex:t

This package is designed to bring [[https://supermemo.guru/wiki/Incremental_writing][incremental writing]], [[https://help.supermemo.org/wiki/Incremental_mail_processing][incremental mail processing]] and incremental [[http://www.literateprogramming.com/][literate programming]] capabilities to org-mode and Emacs.

It works with [[https://github.com/alphapapa/org-ql][org-ql]] in order to find and generate lists of included files.

Key functions we would need:
- A-factor
- Priority
- Postpone/Reschedule (Intra- and inter-day)
- Dismissing (of files and sub-headers)
- Mercy
- TODO keywords: ("to write", "to expand", "to rewrite", "to review", "finished")
- Statistical analysis to chart the progress through the writing material (~magit~ and ~calendar~)
- Outstanding headline sorting by priority to match circadian cycles (high for high alertness and low for end of day)

Features:

  + *Incremental literate programming* with org-mode and SM's algorithm!
  + *Incremental writing of email with ~mu4e~!*
  + Deadline awareness (modify priority/a-factor/scheduled date based on distance to deadline)

* Overview
:PROPERTIES:
:CREATED:  [2021-09-08 Wed 21:38]
:ID:       a981430d-1319-4d5a-b036-c1478fdf7cd4
:END:

** TODO Why incremental writing?
:PROPERTIES:
:CREATED:  [2021-07-26 Mon 17:42]
:ID:       d334935e-79f3-4c5d-a614-61f902e6ecb9
:END:

Incremental writing is a concept co-developed by Piotr Wozniak and [[https://supermemopedia.com/wiki/How_I_use_creative_elaboration_with_the_help_of_incremental_reading][users of Supermemo]] employing the topic spacing feature to break writing projects into sub-chapters, as a form of creative elaboration.

Woz [[http://help.supermemo.org/wiki/Creativity_and_problem_solving_in_SuperMemo#Incremental_writing][writes]]:
#+begin_quote
(Texts)... may be bloated and repetitive, however, with incremental reading, they can be prioritized in a rational way. *Incremental writing leaves the texts highly granular and the flow of thought is jagged*, however ... this is an advantage as all individual articles and subarticles *carry sufficient local context to be read independently*.
#+end_quote

The above relates to the granularity of articles written using IW lending itself to IR as extracts tend to be discrete. In the context of incremental literate programming, I believe the contextualisation provided by prose encapsulated in subheadings offer these same advantages while also then allowing us to use the spacing effect over blocks of code. Org-mode's narrowing and widening features further help to constrain or expand context in the flow of IW.

Donald Knuth's "Literate Programming" is a programming methodology that involves combining human-readable text with code in a way that makes the code more understandable and easier to follow. This is accomplished by treating the code as a form of literature, in which the programmer writes prose to explain and document the code, interspersed with the code itself. The resulting "literate programs" are easier to read and understand than traditional programs, which can make them more maintainable and more likely to be used and reused by others. Additionally, the use of literate programming can make the process of writing and maintaining code more enjoyable and rewarding for the programmer, as it allows them to express themselves and their ideas in a more natural and intuitive way. Overall, the benefits of literate programming include improved readability, maintainability, and reusability of code, as well as increased enjoyment and satisfaction for the programmer.

It is possible to combine Piotr Wozniak's "Incremental Writing" and Donald Knuth's "Literate Programming" into a single concept called "Incremental Literate Programming." Incremental Writing is a method of writing that involves starting with a small amount of text and then gradually adding to it over time, rather than trying to write everything at once. Literate Programming is a programming methodology that involves combining human-readable text with code in a way that makes the code more understandable and easier to follow.

The subheadings can help to structure and organize the code, making it more understandable and easier to follow. Additionally, the use of subheadings can make it easier to use the spacing effect to review and retain blocks of code over time. The narrowing and widening features in org-mode can also be used to constrain or expand the context in the flow of incremental writing, further improving the readability and usability of the code. Overall, the combination of incremental writing and literate programming can provide a powerful and effective way to write and maintain complex programs.

The "spacing effect" is a psychological phenomenon that refers to the tendency for information to be more effectively learned and retained when it is presented and reviewed over a series of spaced intervals, rather than being presented and reviewed all at once. In the context of incremental literate programming, the spacing effect can be used to assist with the learning and retention of blocks of code. By breaking the code up into smaller, manageable units and reviewing them over spaced intervals, the programmer can more effectively commit the code to memory and retain their knowledge of it over time. This can make the code easier to understand and work with, as well as making it more likely that the programmer will be able to recall and use the code when needed. Additionally, the use of the spacing effect can help to make the process of learning and working with code more efficient and less overwhelming, as it allows the programmer to focus on smaller amounts of information at a time.
** NEXT Getting started
:PROPERTIES:
:CREATED:  [2022-07-22 Fri 11:21]
:ID:       141e0838-84a7-4f35-90b3-9ec544c98119
:END:

Example configuration:

#+begin_src elisp :eval no
(use-package! org-incremental
  :config
  (setq org-incremental-todo-keywords '("NEXT")))
#+end_src

* Topic spacing algorithm
:PROPERTIES:
:CREATED:  [2021-07-23 Fri 17:53]
:ID:       b58fcb07-0654-4120-a26a-0347c41b621b
:END:

In short, the basic algo for spacing topics is here:

#+begin_example
(Interval=OldInterval*AFActor)
#+end_example

- The first metric is self explanatory, but ~A-factor~ [fn:1] (standing for /absolute difficulty factor/) is more complicated in that it is used in older versions (<SM18) of Supermemo to represent element difficulty. It is still used for topics but not items in the current version.

The base value for ~A-factor~ in Supermemo is =2=, and so in essence the algo is simply a doubling mechanism:

#+begin_src elisp :noweb-ref a-factor value
(defcustom a-factor 2.0
  "Base a-factor value as per Supermemo defaults"
  :type 'float
  :group 'org-incremental)
#+end_src

As review spacings this is a simple geometric sequence ($x_n=ar^{(n-1)$) with =2= as the common ratio:

#+begin_src lua :noweb yes :noweb-ref geometric sequence lua :results silent
local sequence = {}
function GeoSeq (a, r, n)
   for i = 1, n do
   x = a * r^(i-1)
   sequence[#sequence+1] = x
   end
   return x
end

function print_seq (a, r, n)
  GeoSeq(a, r, n)
  for index, value in ipairs(sequence) do
    print(value)
    -- tex.print(math.floor(value))
  end
end
#+end_src

#+begin_src lua :noweb yes :var a_factor=(eval 'a-factor) :results output pp
«geometric sequence lua»
print_seq(1, a_factor, 5)
#+end_src

#+RESULTS:
: 1.0
: 2.0
: 4.0
: 8.0
: 16.0

#+NAME: geo-progression
#+HEADER: :headers '("\\usepackage{tikz}" "\\usepackage{luacode}")
#+BEGIN_SRC latex :results graphics file :file img/progression.png :noweb yes
% \pgfsetxvec{\pgfpoint{1.5cm}{0cm}}
\begin{luacode}
  «geometric sequence lua»

function print_seq (a, r, n)
  GeoSeq(a, r, n)
  tex.print("")
  for index, value in ipairs(sequence) do
  tex.print(math.floor(value)..[[, ]])
  tex.print("")
  end
end

\end{luacode}

\newcommand\printseqq[3]{\directlua{print_seq(#1,#2,#3)}}

% \printseqq{1}{2}{5}
\begin{tikzpicture}[scale = 0.4]
  \node[above] {$\dfrac{x_n=1 x 2^{(n-1)}$};
  \\
  \draw[latex-latex] (0,0) -- (21,0);
  % \foreach \x in \printseq{1}{2}{5}
  % \draw[->={(\x,0)}, bend left] node [right];
  \foreach \x in {0,...,21}
  \draw[shift={(\x,0)},color=black] (0pt,0pt) -- (0pt,-2pt) node[below]
  {$\x$};
\end{tikzpicture}
#+end_src

#+RESULTS: geo-progression
[[file:img/progression.png]]

These results are then sorted by priority, a user defined variable at the core of both incremental reading and writing.

It should be noted that a key tool in the process is occasionally micromanaging interval lengths, which might grow at an undesirable rate for important articles and thus needs to be manually shortened from time to time.

** Topic spacing algorithm in Elisp
:PROPERTIES:
:CREATED:  [2021-08-31 Tue 15:05]
:ID:       5a4ff6c0-c4a6-4d44-8fdc-aeb488fedaff
:END:

Instead of re-implementing a geometric sequence directly, we'll copy SM's simple function and have our code act off of repetition data written to the ~:PROPERTIES:~ drawer.

In the functional style the interval determining algorithm:
- We use =round= here because human work days are measured in real days, which means we have a full circadian cycle between reps.

#+begin_src elisp :noweb-ref spacing algo :results silent
(defun org-incremental-determine-next-interval (old-interval a-factor)
  "Calcuate new interval for current headline.
Uses: (Interval=OldInterval*AFactor)"
  (let ((next-interval (* old-interval a-factor)))
    (round next-interval)))
#+end_src

** TODO [#2] Store element data externally?                         :incremental:
This can be compared to a geometric sequencer:

#+begin_src elisp :eval no
(defun org-incremental-geometric (a r n)
  "Take the first term `a' and multiply by the common ratio `r'
To produce `n'th value in a sequence"
  (while (> n 1) ;; TODO test that `r' is not 0
    (* a (expt r (1- n)))))
#+end_src

SCHEDULED: <2022-07-31 Sun>
:PROPERTIES:
:CREATED:  [2021-11-30 Tue 18:58]
:ID:       3e1b81b4-ffb9-4bb2-9106-7cd2ec96fb06
:END:

Maybe use ~org-roam's~ dual model - mirror header information in a db which can be accessed for generating views etc.

* Scheduler
:PROPERTIES:
:CREATED:  [2021-08-31 Tue 18:15]
:ID:       e02e162b-2845-4dd2-9e09-b40792302541
:END:

Apply the base algorithm to existing ~:PROPERTIES:~ keys and then write the new interval, moving the previous interval into the "=OLD_INTERVAL=" key.
The element is rescheduled using ~org~'s internal =org-schedule= function which will be used later for building and sorting a que.

#+begin_src elisp :noweb-ref element rescheduler :results silent
(defun org-incremental-smart-reschedule ()
  "Collect values from headline at point and apply topic algo"
  (interactive)
  (let* ((old-interval (org-incremental-element-current-interval))
         (a-factor (org-incremental-element-a-factor))
         (prior-reps (org-incremental-element-total-repeats)))
    (setq new-interval (org-incremental-determine-next-interval old-interval a-factor))
    (org-entry-put (point) "NEW_INTERVAL" (prin1-to-string new-interval))
    (org-schedule nil (time-add (current-time)
                                (days-to-time
                                 new-interval)))
    (org-entry-put (point) "OLD_INTERVAL" (number-to-string old-interval))
    (org-entry-put (point) "TOTAL_REPEATS" (number-to-string (+ 1 prior-reps)))
    (org-set-property "LAST_REVIEWED"
                      (org-incremental-time-to-inactive-org-timestamp (current-time)))))
#+end_src

Let's break down what the scheduler does:

** Scheduling properties
:PROPERTIES:
:CREATED:  [2022-12-06 Tue 11:19]
:END:

#+begin_src elisp :noweb-ref element-properties :results silent
(defvar org-incremental-scheduling-properties
  '("A-FACTOR" "LAST_INTERVAL" "NEW_INTERVAL" "TOTAL_REPEATS"))

(defvar org-incremental-current-element-uuid nil)

(defvar org-incremental-previous-element-uuid nil)

(defcustom org-incremental-a-factor-property "A_FACTOR"
  "Property to store the given element's `a-factor'."
  :type 'string
  :group 'org-incremental)

(defcustom org-incremental-new-interval-property "NEW_INTERVAL"
  "Name of property to store the new interval value."
  :type 'string
  :group 'org-incremental)

(defcustom org-incremental-old-interval-property "OLD_INTERVAL"
  "Name of property to store the old interval value."
  :type 'string
  :group 'org-incremental)

(defcustom org-incremental-total-repeats-property "TOTAL_REPEATS"
  "Name of property to store the total number of repeats."
  :type 'string
  :group 'org-incremental)

(defcustom org-incremental-created-property "CREATED"
  "Property displaying the creation time of an entry."
  :type 'string
  :group 'org-incremental)

(defcustom org-incremental-last-reviewed-property "LAST_REVIEWED"
  "Property displaying the creation time of an entry."
  :type 'string
  :group 'org-incremental)
#+end_src

Convert timestamp to org-mode
#+begin_src elisp :noweb-ref element rescheduler :results silent
(defun org-incremental-time-to-inactive-org-timestamp (time)
  "Convert TIME into org-mode timestamp."
  (format-time-string
   (concat "[" (substring (cdr org-time-stamp-formats) 1 -1) "]")
   time))
#+end_src

** NEXT Next-review date

Lifted from ~org-drill~. Let's use this as a base to calculate an estimate of the next review for the current item.

#+begin_src elisp :eval no :results silent
(defun org-drill-hypothetical-next-review-date (quality)
  "Returns an integer representing the number of days into the future
that the current item would be scheduled, based on a recall quality
of QUALITY."
  (let ((weight (org-entry-get (point) "DRILL_CARD_WEIGHT")))
    (cl-destructuring-bind (last-interval repetitions failures
                                       total-repeats meanq ease)
        (org-drill-get-item-data)
      (if (stringp weight)
          (setq weight (read weight)))
      (cl-destructuring-bind (next-interval _repetitions _ease
                                         _failures _meanq _total-repeats
                                         &optional _ofmatrix)
          (cl-case org-drill-spaced-repetition-algorithm
            (sm5 (org-drill-determine-next-interval-sm5 last-interval repetitions
                                              ease quality failures
                                              meanq total-repeats
                                              org-drill-sm5-optimal-factor-matrix))
            (sm2 (org-drill-determine-next-interval-sm2 last-interval repetitions
                                              ease quality failures
                                              meanq total-repeats))
            (simple8 (org-drill-determine-next-interval-simple8 last-interval repetitions
                                                      quality failures meanq
                                                      total-repeats)))
        (cond
         ((not (cl-plusp next-interval))
          0)
         ((and (numberp weight) (cl-plusp weight))
          (+ last-interval
             (max 1.0 (/ (- next-interval last-interval) weight))))
         (t
          next-interval))))))

(defun org-drill-hypothetical-next-review-dates ()
  "Return hypothetical next review dates."
  (let ((intervals nil))
    (dotimes (q 6)
      (push (max (or (car intervals) 0)
                 (org-drill-hypothetical-next-review-date q))
            intervals))
    (reverse intervals)))
#+end_src

* Elements
:PROPERTIES:
:CREATED:  [2022-03-27 Sun 12:29]
:ID:       54d1f035-1536-451c-bdc9-3355c8597b76
:END:

Much of this is refactored code lifted from [[https://gitlab.com/phillord/org-drill/-/blob/master/org-drill.el][org-drill]] and [[https://www.leonrische.me/pages/org_flashcards.html][org-fc]].

Headlines are considered 'elements' when tagged with the =org-incremental-element-tag=:

#+begin_src elisp :noweb-ref element-options :results silent
(defcustom org-incremental-element-tag "incremental"
  "Tag for marking headlines as incremental writing elements."
  :type 'string
  :group 'org-incremental)

#+end_src

And are drawn from the customizable list of directories:
#+begin_src elisp :noweb-ref element-options :results silent
(defcustom org-incremental-directories (org-agenda-files)
  "Files to searched for elements"
  :type 'string
  :group 'org-incremental)
#+end_src

If wanted, we can further refine our list of actionable candidates by specifying a TODO keyword(s) list:

#+begin_src elisp :noweb-ref element-options :results silent
(defcustom org-incremental-todo-keywords nil
  "If non-nil, supply list as viable TODO keyword(s)
to consider as rep-able `org-incremental' entries"
  :type 'string
  :group 'org-incremental)
#+end_src

** Element properties
:PROPERTIES:
:CREATED:  [2022-08-11 Thu 15:12]
:ID:       93ecad32-6f69-479a-9b5b-8d030af75c73
:END:
** Checking and moving to elements
:PROPERTIES:
:CREATED:  [2022-07-22 Fri 14:20]
:ID:       90ec04c0-2ece-4f34-a74e-81c6ffbcc860
:END:

Here we perform various checks over the element in question
#+begin_src elisp :noweb-ref element-checks :results silent
(defun org-incremental-entry-p ()
  "Check if the current heading is an incrementalised element."
  (member org-incremental-element-tag (org-get-tags nil 'local)))

#+end_src

#+begin_src elisp :noweb-ref element-checks :results silent
(defun org-incremental-operable-entry-p (marker)
  "Is MARKER, or the point, in an operable TODO?"
    (member (org-get-todo-state) org-incremental-todo-keywords))

#+end_src

#+begin_src elisp :noweb-ref element-checks :results silent
(defun org-incremental-entry-new-p ()
  "Return non-nil if the entry at point is new."
  (and (org-incremental-entry-p)
       (let ((element-time (org-get-scheduled-time (point))))
         (null element-time))))
#+end_src

Shouldn't this be using UUID's? What constitutes =marker=?
#+begin_src elisp :results silent
(defun org-incremental-goto-entry (marker)
  "Switch to the buffer and position of MARKER."
  (switch-to-buffer (marker-buffer marker))
  (goto-char marker))
#+end_src

** Element creation
:PROPERTIES:
:CREATED:  [2021-11-29 Mon 12:23]
:ID:       72ca6a31-4fe7-45ae-aba2-2d68711693a0
:END:

#+begin_src elisp :noweb-ref element-creation-functions :results silent
(defun org-incremental--add-tag (tag)
  "Add TAG to the heading at point."
  (org-set-tags
   (cl-remove-duplicates
    (cons tag (org-get-tags nil 'local))
    :test #'string=)))

(defun org-incremental--remove-tag (tag)
  "Add TAG to the heading at point."
  (org-set-tags
   (remove tag (org-get-tags nil 'local))))

#+end_src

The below function is used to create an incrementalized headline. The tagging lets us know that it should be scheduled.

#+begin_src elisp :noweb-ref element-creation-functions :results silent
(defun org-incremental--init-element ()
  "Initialize the current headline as a topic."
  (if (org-incremental-entry-p)
      (error "Headline is already an incremental element"))
  (org-back-to-heading)
  (org-id-get-create)
  (org-expiry-insert-created)
  (org-set-property org-incremental-last-reviewed-property "0") ;; TODO can all this be collapsed?
  (org-set-property org-incremental-total-repeats-property "0")
  (org-set-property org-incremental-old-interval-property "0")
  (org-set-property org-incremental-new-interval-property "1") ;; this kicks off the geo seq
  (org-set-property org-incremental-a-factor-property (number-to-string a-factor))
  (org-incremental--add-tag org-incremental-element-tag)
  (if org-incremental-prompt-for-priority-p
      (let ((org-priority-highest org-incremental-priority-highest)
            (org-priority-lowest org-incremental-priority-lowest)
            (org-priority-default org-incremental-default-priority))
       (org-priority))))
#+end_src

If we use the =#+org_incremental: t= buffer option perhaps we can steal ~org-auto-tangle~'s functionality and check the buffer on save for actionable TODOs or headers that have not yet been initialized and turn them into elements.

** Retrieve element data
:PROPERTIES:
:CREATED:  [2021-11-29 Mon 10:35]
:ID:       3d66a38f-e251-4e81-aeb1-8abdd41c770b
:END:

Bring in some functionality for interacting with data stored the ~:PROPERTIES:~ drawer.

#+begin_src elisp :noweb-ref element-stats :results silent
(defun org-incremental-element-old-interval (&optional default)
  "Return previous interval for element at point."
  (let ((val (org-entry-get (point) "OLD_INTERVAL")))
    (if val
        (string-to-number val)
      (or default 0))))

(defun org-incremental-element-a-factor (&optional default)
  "Return previous interval for element at point."
  (let ((val (org-entry-get (point) "A_FACTOR")))
    (if val
        (string-to-number val)
      (or default 0))))

(defun org-incremental-element-current-interval (&optional default)
  "Return pre-rep interval for element at point."
  (let ((val (org-entry-get (point) "NEW_INTERVAL")))
    (if val
        (string-to-number val)
      (or default 0))))

(defun org-incremental-element-total-repeats (&optional default)
  "Return total number of repeats for the element at point."
  (let ((val (org-entry-get (point) "TOTAL_REPEATS")))
    (if val
        (string-to-number val)
      (or default 0))))

#+end_src

#+begin_src elisp :noweb-ref element-stats :results silent
(defun org-incremental-get-element-data ()
  "Returns a list of 3 elements, containing all the stored recall
  data for the element at point:
- LAST-INTERVAL is the interval in days that was used to schedule the element's
  current review date.
- REPEATS is the number of times the element has been repeated.
- A-FACTOR is the number by which to space out a repped element.
"
  (let ((learn-str (org-entry-get (point) "LEARN_DATA"))
        (repeats (org-incremental-entry-total-repeats :missing)))
    (cond
     (learn-str
      (let ((learn-data (and learn-str
                             (read learn-str))))
        (list (nth 0 learn-data)        ; last interval
              (nth 1 learn-data)        ; repetitions
              (org-incremental-entry-failure-count)
              (nth 1 learn-data)
              (org-incremental-entry-last-quality)
              (nth 2 learn-data)        ; EF
              )))
     ((not (eql :missing repeats))
      (list (org-incremental-entry-last-interval)
            (org-incremental-entry-repeats-since-fail)
            (org-incremental-entry-total-repeats)
            (org-incremental-entry-average-quality)
            (org-incremental-entry-ease)))
     (t  ; virgin element
      (list 0 0 0 0 nil nil)))))
#+end_src

#+begin_src elisp :results silent
(defun org-incremental-days-since-last-review ()
  "Nil means a last review date has not yet been stored for
the element.
Zero means it was reviewed today.
A positive number means it was reviewed that many days ago.
A negative number means the date of last review is in the future --
this should never happen."
  (let ((datestr (org-entry-get (point) org-incremental-last-reviewed-property)))
    (when datestr
      (- (time-to-days (current-time))
         (time-to-days (apply 'encode-time
                              (org-parse-time-string datestr)))))))
#+end_src

** Store element data
:PROPERTIES:
:CREATED:  [2021-11-29 Mon 10:37]
:ID:       7669d568-a905-4adb-b579-d6b5fd0053e3
:END:

#+begin_src elisp
(defun org-drill-store-element-data (last-interval repeats failures
                                                total-repeats meanq
                                                ease)
  "Stores the given data in the element at point."
  (org-entry-delete (point) "LEARN_DATA")
  (org-set-property "DRILL_LAST_INTERVAL"
                    (number-to-string (org-drill-round-float last-interval 4)))
  (org-set-property "TOTAL_REPEATS" (number-to-string total-repeats)))

#+end_src

** checks
:PROPERTIES:
:CREATED:  [2021-11-29 Mon 10:35]
:ID:       b50e5eb3-39da-48fb-af77-8016d12b577b
:END:

We need to introduce checks for valid A-factor and interval values.

#+begin_src elisp
(assert (>= 2 2))
#+end_src

** Delete review data
:PROPERTIES:
:CREATED:  [2022-08-09 Tue 11:40]
:ID:       8d1b2b03-d39a-46a7-a0a7-b90ad714809f
:END:

#+begin_src elisp
(defun org-drill-strip-entry-data ()
  (dolist (prop org-drill-scheduling-properties)
    (org-delete-property prop))
  (org-schedule '(4)))


(defun org-drill-strip-all-data (&optional scope)
  "Delete scheduling data from every drill entry in scope. This
function may be useful if you want to give your collection of
entries to someone else.  Scope defaults to the current buffer,
and is specified by the argument SCOPE, which accepts the same
values as `org-drill-scope'."
  (interactive)
  (when (yes-or-no-p
         "Delete scheduling data from ALL items in scope: are you sure?")
    (cond
     ((null scope)
      ;; Scope is the current buffer. This means we can use
      ;; `org-delete-property-globally', which is faster.
      (dolist (prop org-drill-scheduling-properties)
        (org-delete-property-globally prop))
      (org-drill-map-entries (lambda () (org-schedule '(4))) scope))
     (t
      (org-drill-map-entries 'org-drill-strip-entry-data scope)))
    (message "Done.")))
#+end_src

* Priority system
:PROPERTIES:
:CREATED:  [2021-11-29 Mon 13:24]
:ID:       a327cd46-cad0-450c-8cce-237bd691b47c
:END:

We can piggy back off of some more ~org~ functions:
- =org-default-priority= (30 in this case, with min being 60 and max 1)

Baseline function for setting priority at topic creation.
Inherit from custom priority.

#+begin_src elisp
(org-priority org-incremental-priority-default)
#+end_src

#+begin_src elisp :noweb-ref priority-system :results silent
(defcustom org-incremental-default-priority 'org-default-priority ;; TODO how to make this use system defaults?
  "Use a custom set of default priorities, ")

(defcustom org-incremental-priority-highest 'org-priority-highest
  "Set a custom highest priority for use in `incremental' items
Use the current org-priority if unset")

(defcustom org-incremental-priority-lowest 'org-priority-lowest
  "Set a custom lowest priority for use in `incremental' items
Use the current org-priority if unset")

#+end_src

Note that sorting numerical priorities does not seem to be working in ~org-ql~. See the relevant [[https://github.com/alphapapa/org-ql/issues/274][issue]].

Use a simple 1-10 range for now:
#+begin_src elisp
(setq org-priority-highest 1
      org-priority-lowest 10
      org-priority-default 5)
#+end_src

Experimenting with local
#+begin_src elisp
(setq-local org-priority-highest 1
            org-priority-lowest 10
            org-priority-default 5)
#+end_src

#+begin_src elisp
(setq org-priority-highest ?A
      org-priority-lowest ?Z
      org-priority-default ?M)
#+end_src

This might be useful for setting whether a created subtree implicitly inherits a parent priority (via cookies), inherits it explicitly (the priority is set textually) or via a custom function
#+begin_src elisp :noweb-ref priority-system :results silent
(defcustom org-incremental-priority-inheret 'default
  "Set how priorities are inherited amongst subtrees")
#+end_src

#+begin_src elisp :noweb yes :noweb-ref priority-system :results silent
(defcustom org-incremental-prompt-for-priority-p nil
  "If non-nil, prompt to select headline priority at element creation."
  :group 'org-incremental
  :type 'boolean)
#+end_src

#+RESULTS:
: org-incremental-prompt-for-priority-p

Generic function for visually selecting an elements priority
See ~org-priority~
#+begin_src elisp
(defun org-incremental--select-priority ()
  "")
#+end_src

* Queue
:PROPERTIES:
:CREATED:  [2021-07-23 Fri 16:51]
:ID:       35274ebc-b6d0-41e4-bf68-7749b96f34d2
:END:

To emulate Supermemo's outstanding que, we need to query due (and overdue) items sourced from the ~org-incremental-directories~ with the ~org-todo-keywords-for-agenda~ list and the =incremental= tag in order to bring up an =agenda=-like view of tasks.

#+begin_src elisp :noweb-ref que-options :results silent
(defcustom org-incremental-query
  '(or (and (tags org-incremental-element-tag)
            (todo org-incremental-todo-keywords)
            (scheduled :to today))
       (and (tags org-incremental-element-tag)
            (todo org-incremental-todo-keywords)
            (not (scheduled :from today))))
  "Query to be run by `org-ql'."
  :type 'sexp ;; TODO should this be 'symbol?
  :group 'org-incremental)
#+end_src

In order to ease testing =org-ql-select= is put into its own function.
Results are sorted by priority and date:

#+begin_src elisp :noweb-ref tests :results silent
(defun org-incremental-selection (dir query)
  "Run a `org-ql-select' over DIR against the QUERY."
  (org-ql-select dir query
    :action 'element-with-markers
    :sort '(date priority)))
#+end_src

We require the use of ='element-with-markers= to be able to build the =agenda= like buffer later on. This calls =org-ql--add-markers= internally, and we use this in our test below.

Here we point the above functions + a simple map to an org file included in the repo to test.

#+begin_src elisp :results silent
(ert-deftest selection-test ()
  "Test whether `org-incremental-query' returns the expected que results."
  (setq-local org-incremental-directories "\./demo.org"
              org-incremental-todo-keywords org-todo-keywords)
  (should
   (let ((inhibit-message t))
     (equal
      (org-map-entries
       (lambda ()
         (org-ql--add-markers
          (org-element-headline-parser)))
       "incremental"
       (list (eval org-incremental-directories)))
      (org-incremental-selection org-incremental-directories org-incremental-query)))))

#+end_src

#+begin_src elisp :eval yes :results silent
(ert 'selection-test)
#+end_src


** Constructing the que
:PROPERTIES:
:CREATED:  [2023-03-12 Sun 12:08]
:ID:       f3c73455-6446-4b00-a40d-4c8dd04b08a8
:END:

First an empty variable to store the que as a list with text properties:

#+begin_src elisp :noweb-ref que-vars :results silent
(defvar org-incremental-outstanding-que nil)

#+end_src

*** Midnight shift
:PROPERTIES:
:CREATED:  [2023-03-12 Sun 13:07]
:ID:       acc83d93-e632-499d-aec8-654c547b3d9b
:END:

The outstanding que shows scheduled items based on the current day, which we determine via [[https://supermemopedia.com/wiki/Midnight_shift][midnight shift]].

As mentioned in the /Topic spacing algorithm/ section, the spacing effect relies on sleep cycles between days to consolidated memory and for the formalization of new ideas. As such, we need a time against which to 'tick over' into the new day so that we can be sure that the algorithm is making the right calculations, and not using stale data.

We run this test as /midnight+midnight shift = a new learning day/.

At first, simply setting the shift time as midnight seems logical. However, in an increasingly 'on' world, we might find ourselves working past midnight. Thus it is likely best to set this somewhere in the middle of your usual sleep, i.e. while your brain is consolidating.

#+name: midnight
#+begin_src elisp :noweb-ref midnight-shift-options :results silent
(defvar org-incremental-midnight (make-decoded-time :second 59
                                                    :minute 59
                                                    :hour 23)
  "Canonical midnight")

#+end_src

We can then calculate the midnight time for any given day using the =decoded=time= suite of functions:

#+begin_src elisp :noweb-ref midnight-shift-funcs :results silent
(defun org-incremental-midnight ()
  "Generate midnight time for today."
  (let* ((current-day (decoded-time-day (decode-time)))
         (current-month (decoded-time-month (decode-time)))
         (decoded-day-month (make-decoded-time :second 00
                                               :minute 00
                                               :hour 00
                                               :day current-day
                                               :month current-month)))
    (decoded-time-add decoded-day-month
                      org-incremental-midnight)))

#+end_src

The Supermemo documentation suggests something like a 2 hour shift past midnight.

#+name: midnight shift
#+begin_src elisp :noweb-ref midnight-shift-options :results silent
(defcustom org-incremental-midnight-shift "02:00:00"
  "Time passed when `org-incremental' considers a new day.

    Accepts time in a ISO 8601 time string, or something like
    the RFC 822 date-time, as per the `parse-time-string' function."

  :type 'string
  :group 'org-incremental)

#+end_src

This will be tested against a current session timestamp for the most recent session run.
#+begin_src elisp :noweb-ref midnight-shift-vars :results silent
(defvar org-incremental-current-shift nil
  "Empty time slot to fill with last run `org-incremental-session'.")

#+end_src

Set previous shift?
#+begin_src elisp :noweb-ref midnight-shift-funcs :results silent
(defun org-incremental-set-current-shift ()
  "Store the shift of the current session."
  (setq org-incremental-current-shift (decode-time)))
#+end_src

Here we test for midnight drift
(SEC MIN HOUR DAY MON YEAR DOW DST TZ)
#+begin_src elisp :noweb-ref midnight-shift-funcs :results silent
(defun org-incremental-calculate-midnight-drift (current-shift midnight-shift)
"Calculate whether the currently run session (CURRENT-SHIFT)
is beyond the MIDNIGHT-SHIFT.

  `(SEC MIN HOUR DAY MON YEAR DOW DST TZ)'"

(let ((midnight-drift (decoded-time-add (org-incremental-midnight)
                                        (parse-time-string midnight-shift))))
  (null (time-less-p current-shift midnight-drift))))

#+end_src

*** Outstanding que
:PROPERTIES:
:CREATED:  [2023-03-22 Wed 19:06]
:ID:       4007ad6a-7f08-4836-9f80-2081be991071
:END:
The =org-ql-select= should be its own function. Maybe run as async in the function or call it async in the below function.

I should write some kind of while loop that messages to the user that the que is being constructed.

This should actually be able to construct a que for any given day?

Where am I running the test for current-shift?
#+begin_src elisp :results silent
(defun org-incremental-outstanding-que ()
  "Construct or check today's outstanding que."
  (interactive)
  (if (or (null org-incremental-current-shift)
          (org-incremental-calculate-midnight-drift org-incremental-current-shift org-incremental-midnight-shift)) t
  (let* ((query org-incremental-query)
         (results (org-ql-select org-incremental-directories query
                    :action 'element-with-markers
                    :sort '(date priority))))
    (setq org-incremental-outstanding-que results)))
(eval 'org-incremental-outstanding-que))
#+end_src

  "List outstanding elements via a `org-ql' search"
  (interactive)
  (org-ql-search org-incremental-directories
    '(or (and (tags org-incremental-element-tag)
              (todo "NEXT")
              (scheduled :to today))
         (and (tags org-incremental-element-tag)
              (todo "NEXT")
              (not (scheduled :from today))))
    :sort '(date priority)
    :title "Incremental Elements"))
#+end_src

** NEXT [#O] Incremental repped today                            :incremental:
SCHEDULED: <2022-08-20 Sat>
:PROPERTIES:
:CREATED:  [2022-08-14 Sun 14:35]
:ID:       796e6a52-720b-4b30-b6ab-25f84a52ba64
:LAST_REVIEWED: 0
:TOTAL_REPEATS: 0
:OLD_INTERVAL: 0
:NEW_INTERVAL: 1
:A_FACTOR: 2.0
:END:

We can =pop= into the list while intersession, otherwise if out of session then perform search. We're searching the ~:LAST_REVIEWED:~ property.
#+begin_src elisp :noweb-ref queue-views :results silent
(defun org-incremental-view-completed ()
  "List elements repped today via a `org-ql' search"
  (interactive)
    (org-ql-search org-incremental-directories
      '(and (tags org-incremental-element-tag)
            (todo "NEXT")
            (scheduled >= today))
      :sort '(date priority)
      :title "Incremental Elements"))
#+end_src

Testing blocks
#+begin_src elisp :eval no :results silent
(org-ql-block org-incremental-directories
  '(and (tags org-incremental-element-tag)
        (todo "NEXT"))
  :sort '(date priority)
  :title "Incremental Elements")
#+end_src

Some function to introduce noise into the schedule listing
#+begin_src elisp :results silent

#+end_src

** NEXT [#A] improve incremental goto function                   :incremental:
SCHEDULED: <2022-11-09 Wed>
:PROPERTIES:
:CREATED:  [2022-08-14 Sun 14:34]
:ID:       a3cefb3e-61c9-4426-8f58-3c677f096cb6
:LAST_REVIEWED: [2022-11-01 Tue 12:48]
:TOTAL_REPEATS: 4
:OLD_INTERVAL: 5
:NEW_INTERVAL: 8
:A_FACTOR: 1.68
:TRIGGER:  chain-find-next(NEXT,from-current,priority-up,effort-down)
:END:
maybe save point to go back
I could maybe do the storing in the =org-incremental-smart-reschedule= function.
Should deactivated org-incremental-mode in the previous buffer and activate it in the new buffer.

#+begin_src elisp :noweb-ref queue-goto-functions
#+begin_src elisp :noweb-ref queue-goto-functions :results silent
(defun org-incremental-goto-next ()
  "Rep and go to next outstanding element via a `org-ql' search"
  (interactive)
  (if org-incremental-mode
      (with-current-buffer (current-buffer)
      (progn
        (org-incremental-smart-reschedule)
        (org-incremental-view-outstanding)
        (org-incremental-mode 0))
        ;; (org-ql-view-refresh)
        (with-current-buffer "*Org QL View: Incremental Elements*"
          (org-agenda-switch-to)
          (org-narrow-to-subtree)
          (org-incremental-mode 1)))
    (error "Not in incremental session")))
#+end_src

Go back to recently completed via the =org-incremental-view-recent= function
#+begin_src elisp :noweb-ref queue-goto-functions :results silent
(defun org-incremental-goto-previous ()
  "Rep and go to next outstanding element via a `org-ql' search"
  (interactive)
  (if org-incremental-mode
      (progn
        (org-incremental-smart-reschedule)
        (org-incremental-view-outstanding)
        ;; (org-ql-view-refresh)
        (with-current-buffer "*Org QL View: Incremental Elements*"
          (org-agenda-switch-to)
          (org-narrow-to-subtree)))
    (error "Not in incremental session")))

#+end_src

#+begin_src elisp :results silent
(defun org-incremental-view-recent ()
  "List recently reviewed elements via a `org-ql' search"
  (interactive)
  (org-ql-search org-incremental-directories
    '(or (and (tags org-incremental-element-tag)
              (todo "NEXT")
              (scheduled :to today))
         (and (tags org-incremental-element-tag)
              (todo "NEXT")
              (not (scheduled :from today))))
    :sort '(date priority)
    :title "Incremental Elements"))
(org-incremental-org-last-reviewed-property)
#+end_src

** NEXT Write simple goto function
:PROPERTIES:
:TRIGGER:  chain-find-next(NEXT,from-current,priority-up,effort-down)
:END:

#+begin_src elisp :noweb-ref simple-queue-goto-functions
(defun org-incremental-simple-goto-next ()
  "Rep and go to next outstanding element via a `org-ql' search."
  (interactive)
  (progn
    (with-current-buffer "*Org QL View: Training*"
      (org-agenda-next-item 1)
      (org-incremental-org-brain-agenda))
    (with-current-buffer "*Org QL View: Training*"
      (org-agenda-previous-item 1)
      (org-incremental-simple-reschedule)
      (org-ql-view-refresh))))

#+begin_src elisp :noweb-ref simple-queue-goto-functions :results silent
(defun org-incremental-org-brain-agenda ()
  "Pop org-brain visualise from agenda."
    (let* ((marker (org-get-at-bol 'org-marker))
           (id-from-marker (org-id-get marker))
           (entry-from-id (org-brain-entry-from-id id-from-marker)))
      (org-brain-visualize entry-from-id))))
#+end_src

** NEXT rep-reschedule
:PROPERTIES:
:TRIGGER:  chain-find-next(NEXT,from-current,priority-up,effort-down)
:CREATED:  [2022-08-15 Mon 15:42]
:ID:       0a49de46-60e0-49b1-843c-6b2aa1f44524
:END:

** Check out
:PROPERTIES:
:CREATED:  [2022-03-26 Sat 20:26]
:ID:       cf68e7c3-3b4c-4fd1-8251-f5fa9df31532
:END:

https://github.com/alphapapa/org-ql/issues/88
memoization

* Interface
:PROPERTIES:
:CREATED:  [2021-10-09 Sat 14:49]
:ID:       ec51031f-ca20-4842-89d4-e9bbf7247629
:END:

** Storing views
:PROPERTIES:
:CREATED:  [2022-08-21 Sun 13:55]
:ID:       a7646e02-20ad-4074-827d-aebd07e44349
:END:

A nice ability would be saving and storing a particular project layout at a given element. This would allow us to return to working on that headline much faster as all the resources would be made available when it is traversed to in the queue.

Things we might want to store:

- Buffer position
- Cursor position
- Opened buffers
- Window layout
- Related resources (links, info nodes etc.)

Let's have this as an optional user-defined setting so as not to interfere with individual workflows:

#+begin_src elisp :results silent
(defcustom org-incremental-store-view-p nil
  "If non-nil store the current window layout to the current headline"
  :type 'boolean
  :group 'org-incremental)
#+end_src

#+begin_src elisp
(defcustom org-incremental-store-view-function "")
#+end_src

A promising package to enable this functionality is alphapapa's [[https://github.com/alphapapa/burly.el][burly]] in tandem with ~bookmark+~.

*** TODO Repair ~bkmp-bookmark-record-from-name-error~
:PROPERTIES:
:CREATED:  [2022-11-01 Tue 12:45]
:ID:       ce518549-1aa0-4afa-968b-73e34c2243f0
:END:
Currently I am experiencing a bug with ~bookmark+~ where while attempting to restore some part of the ~burly~ bookmark, =nil= is passed and ~eww~ buffers are restored but not placed in the correct window configuration:

=error in process filter: bmkp-bookmark-record-from-name: No such bookmark in bookmark list: ‘’=

How to write a test in Emacs?
#+begin_src elisp
(bmkp-bookmark-record-from-name)
#+end_src

** hydra
:PROPERTIES:
:CREATED:  [2021-10-09 Sat 14:50]
:ID:       86e613a9-b9f0-4f11-a181-fad65c3cf9af
:END:

** transient
:PROPERTIES:
:CREATED:  [2022-03-26 Sat 12:27]
:ID:       faa31d73-bdec-41f7-a679-b8d37d9e13cc
:END:

https://www.reddit.com/r/emacs/comments/f3o0v8/anyone_have_good_examples_for_transient/
https://gist.github.com/abrochard/dd610fc4673593b7cbce7a0176d897de
https://github.com/emacs-mirror/emacs/blob/master/lisp/international/emoji.el
https://github.com/magit/transient
https://github.com/magit/transient/wiki/Developer-Quick-Start-Guide

#+begin_src elisp :results silent
(transient-define-prefix transient-toys-hello ()
  "Say hello"
   [("h" "hello" (lambda () (interactive) (message "hello")))])
#+end_src

#+RESULTS:
| [1 transient-column nil ((1 transient-suffix (:key h :description hello :command transient:transient-toys-hello:hello)))] |

*** NEXT Brainstorm org-incremental-transient functions
:PROPERTIES:
:CREATED:  [2022-08-14 Sun 14:36]
:ID:       07e3baf0-a75f-44ae-9a53-0597d7a0c539
:END:
** other HUDs
:PROPERTIES:
:CREATED:  [2021-10-09 Sat 14:50]
:ID:       c44afafd-b231-41e9-a80a-a6346be3b4ae
:END:

https://github.com/sp1ff/elfeed-score

** Dashboard
:PROPERTIES:
:CREATED:  [2021-11-29 Mon 10:14]
:ID:       f5090ae0-6e6f-4791-9de8-0f25e8d6f66e
:END:

** Modeline
:PROPERTIES:
:CREATED:  [2021-11-29 Mon 10:14]
:ID:       3f00e540-59f1-432a-9b4e-24388ffb250f
:END:

* org-incremental-mode
:PROPERTIES:
:CREATED:  [2022-07-22 Fri 10:46]
:ID:       60d92f2f-3642-4643-9386-9df0fc992a70
:END:

#+begin_src emacs-lisp :noweb yes :noweb-ref minor-mode :results silent
 (define-minor-mode org-incremental-mode
   "Incremental writing for org-mode"
   :lighter "org-incremental-session"
   :keymap)
#+end_src

Check whether buffer is an incrementalised one.
#+begin_src elisp :results silent
(defun org-incremental-find-value (buffer)
  "Search the `org-incremental' property in BUFFER and extracts it when found."
  (with-current-buffer buffer
    (save-excursion
      (save-restriction
        (widen)
        (goto-char (point-min))
        (when (re-search-forward (org-make-options-regexp '("org_incremental")) nil :noerror)
          (match-string 2))))))
#+end_src

#+begin_src elisp :results silent
(defun org-incremental ()
  "Start an interactive org-incremental session"
  (interactive)
  (if org-incremental-mode
      (error "Already in an incremental writing session")
    (org-incremental-mode 1))
  (org-incremental-view-outstanding)
  (with-current-buffer "*Org QL View: Incremental Elements*"
    (org-agenda-switch-to)
    (org-narrow-to-subtree)))

#+end_src

* Ideas
:PROPERTIES:
:CREATED:  [2022-02-21 Mon 12:21]
:ID:       98206206-e278-4201-ad9c-d5980918c785
:END:

** TODO [#6] Could write a hook for git + ~org-incremental~ properties :incremental:
SCHEDULED: <2022-07-31 Sun>
:PROPERTIES:
:CREATED:  [2022-02-21 Mon 12:21]
:ID:       d6c90be8-e27b-4629-81ee-fb8cadbf525a
:END:

Hook git to commit the text created by turning a heading into an element

** TODO Brainstorm: Edna org-ql blocking incremental search function should filter for in buffer elements first
:PROPERTIES:
:CREATED:  [2022-07-18 Mon 22:59]
:ID:       d99cbb5e-0c71-44d4-ae0d-4d3f395f7374
:END:

Not sure what I was thinking here

Am I going to use EDNA as part of org-incremental?

** TODO Include org doc in package
:PROPERTIES:
:CREATED:  [2022-07-18 Mon 22:59]
:ID:       c39aa618-f189-4e1c-9192-8f402f3000ae
:END:

Write help view function (like doom)

** TODO Deincrementalizer
:PROPERTIES:
:CREATED:  [2022-08-09 Tue 11:40]
:ID:       199ceebe-3579-40ff-b62f-38ad54d43dc8
:END:
Write a function that /deincrements/ a given headline/element that has a deadline at some mid distance along its sequence.

#+begin_src elisp :noweb-ref deincrementalizer :results silent
(defcustom org-incremental-deincrement-p nil
  "Boolean to switch on the `deincrementalizer' if non-nil"
  :type 'boolean
  :group 'org-incremental)
#+end_src

#+begin_src elisp :noweb-ref deincrementalizer :results silent
(defun org-incremental-deincrementalizer ()
  "Deincrementalize towards a deadline at some optimal distance"
  (if org-incremental-deincrement-p t))
#+end_src
** TODO mail integration
:PROPERTIES:
:CREATED:  [2022-08-09 Tue 11:40]
:ID:       a52386ff-0e62-498f-bc9f-0a0db4bde7d6
:END:
** TODO Mercy/spread functonality
:PROPERTIES:
:CREATED:  [2022-08-09 Tue 11:40]
:ID:       bf1aaa18-1147-4190-a6a0-6b0d32051cd0
:END:
** TODO Statistical analysis functions
:PROPERTIES:
:CREATED:  [2022-08-09 Tue 11:40]
:ID:       35af54c9-7f19-4fa3-b096-2d4b4f969a38
:END:
** TODO git and magit integration
:PROPERTIES:
:CREATED:  [2022-08-09 Tue 11:40]
:ID:       859db2df-c980-4543-9898-b149e77f3ab3
:END:

** TODO [#2] Store element data externally?                      :incremental:
SCHEDULED: <2022-07-31 Sun>
:PROPERTIES:
:CREATED:  [2021-11-30 Tue 18:58]
:ID:       3e1b81b4-ffb9-4bb2-9106-7cd2ec96fb06
:END:

Maybe use ~org-roam's~ dual model - mirror header information in a db which can be accessed for generating views etc.

* Notes
:PROPERTIES:
:CREATED:  [2022-07-29 Fri 11:15]
:ID:       6bc70751-cc03-4d48-ad29-acd906f43f08
:END:

[fn:1] :: As it stands the value of the A-factor is not necessarily optimised to make use of the spacing effect. By Woz's own admission the current topic algorithm mostly serves as an obsolescence protocol, to push articles further and further out, and thus relies on user intervention in the form of modifying priorities (this is in-line with the current model) and micromanaging interval rescheduling. The latter is not too painful but we could likely be smarter about this.

* Resources
:PROPERTIES:
:CREATED:  [2022-03-26 Sat 12:31]
:ID:       08b151d6-e27e-495d-8d3a-e17752d4cd3d
:END:

- Justifications for incremental writing:
- https://www.masterhowtolearn.com/2020-06-09-incremental-writing-no-more-writer-block/
- https://help.supermemo.org/wiki/Incremental_learning#Incremental_writing
- https://www.masterhowtolearn.com/2020-08-09-the-magic-behind-incremental-writing-spacing-and-interleaving/

Some documentation for the incremental writing algorithm can be found at:
- https://help.supermemo.org/wiki/Creativity_and_problem_solving_in_SuperMemo#Incremental_writing_algorithm
- https://supermemopedia.com/wiki/SM_Algorithm_for_topics_%3F
- http://supermemopedia.com/wiki/How_was_the_topic_algorithm_created%3F
- http://supermemopedia.com/wiki/ABC_of_incremental_reading_for_any_user_of_spaced_repetition
- https://supermemo.guru/wiki/A-Factor

Existing SRS algorithms in Emacs:
- https://github.com/emacsmirror/org-contrib/blob/master/lisp/org-learn.el
- https://gitlab.com/phillord/org-drill
- https://github.com/l3kn/org-fc
- https://github.com/abo-abo/pamparam

Other implementations:
- https://github.com/bjsi/incremental-writing/blob/master/src/scheduler.ts

* Files
:PROPERTIES:
:CREATED:  [2021-09-08 Wed 21:45]
:ID:       7f0e3ea9-aca0-4df4-add7-cc63f111f40d
:END:

** License
:PROPERTIES:
:CREATED:  [2021-09-08 Wed 21:52]
:ID:       0bbb98b5-df68-41d9-a16d-54099acb3d0f
:END:

#+begin_src elisp :mkdirp yes :noweb yes :noweb-ref license :results silent
;;; Header:

;; Author: Daniel Otto
;; Version: 0.0
;; Package-requires: ((emacs "26.3") (org "9.4"))

;; URL: https://github.com/nanjigen/org-incremental

;; Copyright (C) 2021-2023 Daniel Otto

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <https://www.gnu.org/licenses/>.

;;; Commentary:
;;
;; Incremental writing for org-mode
;;
#+end_src

#+begin_src elisp :mkdirp yes :noweb yes :tangle org-incremental.el
;;; org-incremental.el --- Incremental Writing System for org-mode -*- lexical-binding: t; -*-

«license»
;;; Code:

;;;; Requirements
(require 'cl-lib)
(require 'org)
(require 'org-element)
(require 'org-id)
(require 'org-ql)
(require 'org-incremental-scheduler)
(require 'org-incremental-simple)

;;;; Constants

#+end_src

Customizations
#+begin_src elisp :mkdirp yes :noweb yes :tangle org-incremental.el :results silent
(defgroup org-incremental nil
  "Settings for incremental writing in org."
  :group 'external
  :group 'text)

«a-factor value»
#+end_src

Prompt selections for saving and committing after sessions.
#+begin_src elisp :mkdirp yes :noweb yes :tangle org-incremental.el :results silent
(defcustom org-incremental-save-buffers-after-writing-sessions-p nil
  "If non-nil, prompt to save all modified buffers when a session ends."
  :group 'org-incremental
  :type 'boolean)
#+end_src

#+begin_src elisp :mkdirp yes :noweb yes :tangle org-incremental.el :results silent
(defcustom org-incremental-commit-after-writing-sessions-p nil
  "If non-nil, prompt to save all modified buffers when a session ends."
  :group 'org-incremental
  :type 'boolean)
#+end_src

#+begin_src elisp :mkdirp yes :noweb yes :tangle org-incremental.el :results silent
(defcustom org-incremental-narrow-visibility 'minimal
  "Visibility of the current heading during review.
See `org-show-set-visibility' for possible values"
  :type 'symbol
  :group 'org-incremental
  :options '(ancestors lineage minimal local tree canonical))
#+end_src

#+begin_src elisp :mkdirp yes :noweb yes :tangle org-incremental.el
«element-options»

«element-properties»

;; Mode
«minor-mode»

;;; Elements
«element-properties»

;; Initialize elements
«element-creation-functions»

;; Check elements
«element-checks»

;; Check elements
«element-stats»

;; Priority
«priority-system»

;; Queue
«queue-views»

«queue-goto-functions»

;;; Footer

(provide 'org-incremental)

;;; org-incremental.el ends here
#+end_src

** org-incremental-simple.el

#+begin_src elisp :mkdirp yes :noweb yes :tangle org-incremental-simple.el :results silent
;;; org-incremental-simple.el --- Incremental Writing System for org-mode -*- lexical-binding: t; -*-

;;;Commentary

;;; Code:
(require 'org)
(require 'org-ql)
(require 'org-brain)

«simple-configurations»

«view-simple»

«simple-reschedule»

«simple-queue-goto-functions»

(provide 'org-incremental-simple)

;;; org-incremental.el ends here
#+end_src

** org-incremental/org-incremental-scheduler.el
:PROPERTIES:
:CREATED:  [2021-09-08 Wed 21:52]
:ID:       b135bb8c-53c6-4fe2-b78a-22d7f3e89511
:END:

#+begin_src elisp :mkdirp yes :noweb yes :tangle org-incremental-scheduler.el :results silent
;;; org-incremental-scheduler.el --- Incremental Writing System for org-mode -*- lexical-binding: t; -*-
«license»

;;; Code

«spacing algo»

«element rescheduler»

;;; Footer

(provide 'org-incremental-scheduler)

;;; org-incremental-scheduler.el ends here
#+end_src

** org-incremental/org-incremental-hydra.el
:PROPERTIES:
:CREATED:  [2021-09-08 Wed 21:52]
:ID:       c107d6a7-0639-427c-ae3e-2030d2173936
:END:

#+begin_src elisp :mkdirp yes :noweb yes :tangle org-incremental-hydra.el :results silent
;;; org-incremental-hdyra.el --- Incremental Writing System for org-mode -*- lexical-binding: t; -*-
«license»
#+end_src

** org-incremental/org-incremental-analysis.el
:PROPERTIES:
:CREATED:  [2021-09-08 Wed 21:52]
:ID:       dd022a74-bfc0-4ce0-9b38-f9be59be2375
:END:

#+begin_src elisp :mkdirp yes :noweb yes :tangle org-incremental-analysis.el :results silent
;;; org-incremental-analysis.el --- Incremental Writing System for org-mode -*- lexical-binding: t; -*-
«license»
#+end_src

** org-incremental/tests.el
:PROPERTIES:
:CREATED:  [2023-03-29 Wed 07:43]
:ID:       a4705e98-3211-4643-b7f3-0bee7236b906
:END:
#+begin_src elisp :mkdirp yes :noweb yes :tangle tests/el :results silent
;;; tests.el --- Incremental Writing System for org-mode -*- lexical-binding: t; -*-

;;; Code
(require 'ert)
(require 'buttercup)
«tests»
#+end_src

* COMMENT local variables
:PROPERTIES:
:CREATED:  [2021-08-17 Tue 22:49]
:ID:       e99d9699-e0df-4736-b63f-cb6a9ced3142
:END:

# Local Variables:
# org-babel-noweb-wrap-start: "«"
# org-babel-noweb-wrap-end: "»"
# End:
